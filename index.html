<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Bloomcase - d3 prototype V1</title>
<link href="style.css" rel="stylesheet" type="text/css" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script src="d3.v2.min.js"></script>
</head>

<body>

<svg id="timeline">
</svg>
<div id="info">
</div>

<script>
	// variables for processing data
	var format = d3.time.format("%Y-%m-%d-%H-%M-%S");
	var originNodes = [];
	var endNodes =[];
	var links = [];
	var nodes = [];


	// START getData function
	function getData(myData) {
		nodes = myData;

		// reusable function for converting nested elements from string to int
		function nestedToInt(myNest) {
			myNest.forEach(function(d){
				d.forEach(function(nestedElement) {
					nestedElement = parseInt(nestedElement);
				})
			});
		}		
		
		// START loop through data
		nodes.forEach(function(d) {
			// parse data
			d.nid = parseInt(d.nid);
			d.timestamp = format.parse(d.timestamp);
			
			// convert evolvedFrom/To strings to arrays
			d.evolvedFrom = d3.csv.parseRows(d.evolvedFrom);
			d.evolvedTo = d3.csv.parseRows(d.evolvedTo);

			// convert evovledFrom/To data to ints
			nestedToInt(d.evolvedFrom);
			nestedToInt(d.evolvedTo);

			// find all origin nodes
			if(d.evolvedFrom == false) {
				originNodes.push(d.nid);
			}
			
			// find all end nodes
			if(d.evolvedTo == false) {
				endNodes.push(d.nid);
			}

			// set default weight
			d.weight = 1;

			// set default myLongestPath
			d.myLongestPath = 0;
			
		}) // * END loop through data *
		
		console.log ("ORIGIN NODES ARE:", originNodes);
		console.log ("END NODES ARE:", endNodes);
		

		// * * * FIND NODE COLUMN GROUPS * * *

		// set default counts
		var longestCount = 0;
		var tempCount = 0;
		// myInts is where we store the column group numbers
		var myInts = [];
		// populate with default values
		for (var i=0; i<nodes.length; i++) {
			myInts[i+1] = 0;
		}

		// START countSteps function - this gets longest path on the map!
		function countSteps(myNodes, parents, chain) {
			// START loop through nodes array
			//console.log("Starting my loop on the following nodes...", nodes);
			for (var i=0; i<myNodes.length; i++) {
				console.log("* * * * * * * * * * * * COUNTING NODE ID:", myNodes[i]);

				// if node is an origin node, reset the tempCount because we've started a new path
				if(originNodes.indexOf(myNodes[i]) != -1) {
					tempCount = 0;
				}
				console.log("tempcount:", tempCount);
				console.log("parents:", parents-1);
				if(tempCount > parents-1) {
					tempCount = parents-1;
				}

				//add node at specific position
				chain[tempCount] = myNodes[i];
				console.log("node added to chain at position:", tempCount);
				// remove all elements in chain after this node
				for(var j=chain.length-1; j>0; j--) {
					if (j>tempCount) {
						chain.splice(j,1);
					}
				}

				// get evolvedTo data for this node
				var newNodes = nodes[myNodes[i]-1].evolvedTo;
				// temp array to store integer values of node IDs for newNodes
				var newNodesInts = [];
				
				// convert newNodes data to ints and save to temp array
				newNodes.forEach(function(d){
					d.forEach(function(nestedElement) {
						nestedElement = parseInt(nestedElement);
						newNodesInts.push(nestedElement);
					})
				});
				console.log("My children are:", newNodesInts);

				// check whether sotred col group for that node is less than number of parents, if so, set col group = parents
				if(myInts[myNodes[i]] < parents) {
					myInts[myNodes[i]] = parents;
				}

				// see if node has NO evolvedTo data - I've hit a dead end.
				if(newNodesInts.length === 0) {
					// if tempCount is bigger than longestCount
					if(tempCount > longestCount) {
						// we found a new longest count!
						longestCount = tempCount;
					}
					console.log("I've hit a dead end at node", myNodes[i]);
					console.log("My longest chain:", chain);

					// loop through all nodes in chain and assign myLongestPath
					for(var k=0; k<chain.length; k++) {
						var thisNode = nodes[chain[k]-1];
						var longestPath = chain.length;
						// check if existing myLongestPath is less than the new one we found
						if(thisNode.myLongestPath < longestPath) {
							thisNode.myLongestPath = longestPath;
							console.log("node was updated:", thisNode + " to longestPath: " + thisNode.myLongestPath);
						}
					}

					if(tempCount > parents-1) {
						tempCount = parents-1;
					}
					
				} else { // if there are children nodes

					// increase the tempCount to match # of parents
					tempCount = parents;
					console.log("My chain:", chain);
					
					// run the recursive function, pass it the children nodes, the new tempCount, and the chain to track nodes that have come before
					countSteps(newNodesInts, tempCount + 1, chain);
				}
			} // * END loop through nodes *

		} // * END countSteps function *

		// run the countSteps function
		countSteps(originNodes, 1, []);
		console.log("Number of columns on my map:", longestCount+1);


		// * * * FIX ORIGIN NODE POSITIONS * * * 
		// START loop through origin nodes
		for (var i=0; i<originNodes.length; i++) {
			// get evolvedTo data
			var myChildren = nodes[originNodes[i]-1].evolvedTo;
			myChildrenInts = [];

			// convert to integers and store in temp array
			myChildren.forEach(function(d){
				d.forEach(function(nestedElement) {
					nestedElement = parseInt(nestedElement);
					myChildrenInts.push(nestedElement);
				})
			});

			// find lowest number of children col
			myChildPos = [];
			for (var j=0; j<myChildrenInts.length; j++) {
				myChild = myInts[myChildrenInts[j]];
				myChildPos.push(myChild);
			}

			// find the lowest position of children
			lowestChild = d3.min(myChildPos);

			// check if my current colNum is less than that of children
			if (myInts[originNodes[i]] < (lowestChild-1)) {
				// change my column number to be 1 degree removed from closest child
				myInts[originNodes[i]] = lowestChild - 1;
			}
		} // * END loop through origin nodes


		// * * * SET NODE (X,Y) POSITIONS and MAP DIMENSIONS * * * 

		// calculate chart width based on longest count
		var gridSpacing = 100;
		var margin = 2*gridSpacing;
		var mapWidth = (gridSpacing*longestCount);
		var chartWidth = (mapWidth + 2*margin);

		// Update columnGroup and set initial x for each node
		for (var i=0; i<nodes.length; i++) { 
			colPos = myInts[i+1];
			nodes[i].columnGroup = colPos;
			var nodesX = (chartWidth/2 - mapWidth/2) + ((colPos - 1) * gridSpacing);
			nodes[i].x = nodesX;
			nodes[i].px = nodesX;
		}

		// loop through each column and sort nodes by timestamp
		var nest = d3.nest()
		    .key(function(d) { return d.columnGroup; })
		    .sortValues(function(a,b) { return ((a.timestamp < b.timestamp) ? -1 : 1); return 0;} )
		    .entries(nodes);
		console.log("nest: ", nest);

		// find the tallest column
		var columnCounts = [];
		for(var i=0; i<nest.length; i++) {
			// keep track of the length of each column in a new array
			columnCounts.push(nest[i].values.length);
		}
		var tallestColumn = d3.max(columnCounts);

		// set chartHeight based on tallest column
		var mapHeight = (tallestColumn*gridSpacing);
		var chartHeight = mapHeight + margin;

		// set y positions for each node
		for (var i=0; i<nodes.length; i++) {
			// which column am I in?
			var myColumn = nodes[i].columnGroup;
			var myNid = nodes[i].nid;
			//console.log("my NID", myNid);
			// get how many total are in this column and calculate column height
			var myColHeight = (columnCounts[myColumn-1])*(gridSpacing/2);
			// get position of this node in context of column array
			var nestedNodes = nest[myColumn-1].values;
			// use variable to set nest position
			var myNestPos = 0;
			for(var j = 0; j < nestedNodes.length; j++) {
				if(nestedNodes[j].nid === myNid) {
					myNestPos = j;
					nodes[j].myNestPosition = myNestPos;
				}
			}
			console.log("my nest position is", myNestPos + " for nid " + myNid);

						// if node has children and is in a column group larger than 2, place relative to myLongestPath
						if ((nodes[i].evolvedTo != false) && (nestedNodes.length > 2)) {
							var middleOfCol = Math.round(nestedNodes.length/2);
							// remove item from the nest
							nestedNodes.splice(myNestPos, 1);
							// place item back in the middle
							nestedNodes.splice(middleOfCol, 0, nodes[i]);
							nodes[i].myNestPosition = middleOfCol;
							console.log("my updated column", nestedNodes);
							console.log("my NEW nest position is", middleOfCol + " for nid " + myNid);
						}

			// TO DO:
			// assign position in nested array based on myLongestPath, where larger numbers are towards the center of the array
			// for nodes that have the same value, use timestamp to decide who comes first
			// target origin or end nodes that are NOT part of longest path and force them to be relative to their children and smaller numbers for myLongestPath


			// calculate y position based on nest position
			var yPos = (margin/2) + ((mapHeight - myColHeight)/2) + (myNestPos * gridSpacing/2);
			
			// set default y positions for entry, but don't set as fixed
			nodes[i].y = yPos;
			nodes[i].py = yPos;

			/*// round to nearest 50px for Y
			var gridNum = 50;
			nodes[i].y = gridNum * Math.floor((nodes[i].y/gridNum)+0.5);
			nodes[i].py = gridNum * Math.floor((nodes[i].py/gridNum)+0.5);*/

			// set y positions only for origin and end nodes on longest path
			if(nodes[i].nid == 1 || nodes[i].nid == 2 || nodes[i].nid == 11 || nodes[i].nid == 12) {
				nodes[i].fixed = true;
			}
			
		}
		console.log("NEW nest: ", nest);


		// * * * CREATE LINKS ARRAY * * *
		for (var i=0; i<nodes.length; i++) {
			// find evolvedTo for this node
			var myChildren = nodes[i].evolvedTo;
			myChildrenInts = [];
			// convert to integers and store in temp array
			myChildren.forEach(function(d){
				d.forEach(function(nestedElement) {
					nestedElement = parseInt(nestedElement);
					myChildrenInts.push(nestedElement);
				})
			});
			// if evolvedTo is not empty
			if(myChildrenInts.length != 0) {
				// loop through for each child
				for (var j=0; j<myChildrenInts.length; j++) {
					// add to links array
					var newLink = {source: (nodes[i].nid - 1), target: (myChildrenInts[j]-1)};
					links.push(newLink);
				}
			}
		}
		console.log("NODES:", nodes);
		console.log("LINKS:", links);


		// * * * DRAW THE MAP * * *

    	/*var testNodes = [
    		{title: "Node 1", group: 1, x: (chartWidth/2 + 0), y: (chartHeight/2 - 50), fixed: true},
    		{title: "Node 2", group: 1, x: (chartWidth/2 + 0), y:(chartHeight/2 + 50), fixed: true},
    		{title: "Node 3", group: 2, x: (chartWidth/2 + 100), y:(chartHeight/2), fixed: true},
    		{title: "Node 4", group: 3, x:(chartWidth/2 + 200), y: (chartHeight/2), fixed:true}
		];
		var testLinks = [{source: 0, target:2}, {source: 1, target:2}, {source:2, target:3}];
		console.log("testNodes:", testNodes);
		console.log("testLinks:", testLinks);*/

		// draw the SVG
		var svg = d3.select("#timeline")
			.attr("width", chartWidth)
	    	.attr("height", chartHeight);

	    var force = d3.layout.force()
		    .gravity(.06)
		    .distance(100)
		    .charge(-2000)
		    .theta(1)
		    .linkStrength(.5)
		    .friction(.1)
		    .size([chartWidth, chartHeight])
			.nodes(nodes) // target nodes data
			.links(links) // target links data
			.start();

		var link = svg.selectAll(".link")
			.data(links) // target links data
			.enter().append("path")
			.attr("class", "link");

		var node = svg.selectAll(".node")
			.data(nodes) // target nodes data
			.enter().append("g")
			.attr("class", "node")
			.call(force.drag);

		node.append("path")
			.attr("class", function(d){ return d.kind; })
			.attr("d", function(d) {
				switch(d.kind) {
					case "inspiration":
						return "M24.248,26.755H2.833c-1.404,0-2.548-1.143-2.548-2.548V2.793c0-1.405,1.144-2.548,2.548-2.548h21.415 c1.405,0,2.549,1.143,2.549,2.548v21.414C26.796,25.612,25.653,26.755,24.248,26.755z";
						break;
					case "final":
						return "M47.392,44.295c0,1.709-1.388,3.096-3.097,3.096H3.096C1.386,47.391,0,46.004,0,44.295V3.096 C0,1.386,1.386,0,3.096,0h41.199c1.709,0,3.097,1.386,3.097,3.096V44.295z";
						break;
					case "draft":
						return "M31.42,34.758H3.341C1.5,34.758,0,33.26,0,31.419V3.341C0,1.499,1.5,0,3.341,0H31.42 c1.843,0,3.342,1.499,3.342,3.341v28.079C34.762,33.26,33.263,34.758,31.42,34.758z";
						break;
					case "sketch":
						return "M23.963,26.51H2.548C1.143,26.51,0,25.367,0,23.962V2.548C0,1.143,1.143,0,2.548,0h21.415 c1.405,0,2.549,1.143,2.549,2.548v21.414C26.511,25.367,25.368,26.51,23.963,26.51z";
						break;
					case "idea":
						var myWidth = 34; 
						var myHeight = 39;
						return "M16.897,0C14.483,7.241,7.241,16.896,0,19.311c7.241,2.414,14.483,12.069,16.897,19.312 c2.414-7.241,9.654-16.896,16.896-19.312C26.551,16.896,19.311,7.241,16.897,0z";
						break;
				}
		})
		.attr("transform", function(d) { 
			switch(d.kind) {
					case "inspiration":
						var myWidth = 27; 
						var myHeight = 27;
						return "translate(" + (-1*(myWidth/2)) + "," + (-1*(myHeight/2)) + ")"; 
						break;
					case "final":
						var myWidth = 47.4; 
						var myHeight = 47.4;
						return "translate(" + (-1*(myWidth/2)) + "," + (-1*(myHeight/2)) + ")"; 
						break;
					case "draft":
						var myWidth = 35; 
						var myHeight = 34.8;
						return "translate(" + (-1*(myWidth/2)) + "," + (-1*(myHeight/2)) + ")"; 
						break;
					case "sketch":
						var myWidth = 26.5; 
						var myHeight = 26.5;
						return "translate(" + (-1*(myWidth/2)) + "," + (-1*(myHeight/2)) + ")"; 
						break;
					case "idea":
						var myWidth = 33.8; 
						var myHeight = 38.6;
						return "translate(" + (-1*(myWidth/2)) + "," + (-1*(myHeight/2)) + ")"; 
						break;
				}
		});

		node.append("circle")
			.attr("class", "circle")
			.attr("r", 25);

		var circles = d3.selectAll("circle");
		circles.on("mouseover", function(d) {
			//d3.select(this).style("fill", "#3434fe")
		})
		circles.on("mouseout", function(d) {
			//d3.select(this).style("fill", "#000000")
		})
		circles.on("click", function(d) {
			console.log("click!", d)
			nodePopup(d);
		})

		function nodePopup(data) {
			console.log(data);
			var info = d3.select("#info").html("");
          	info.append("div")
          		.attr("class", "img-thumb")
          		.append("img")
          			.attr("src", data.imageUrl);
          	info.append("div")
      			.attr("class", "node-title")
      			.text(data.title);
      		info.append("div")
      			.attr("class", "node-summary")
      			.text(data.summary);

			/*var info = d3.selectAll("#info").selectAll("div.info")
        		.data([data]);
      		var enter = info.enter()
		        .append("div")
		        .classed("info", true);
      		console.log("enter", enter);

      		enter
        		.append("img");
      		enter
        		.append("span");

	      	info.select("span").text(function(d) { return d.data.title })
	      	info.select("img").attr("src", function(d) { 
	        	if(d.data.thumbnail)
	          		return d.data.thumbnail 
	        		return "http://blogs-images.forbes.com/gregvoakes/files/2012/06/reddit-logo.jpeg"
	      		})
	      	.attr("width", 60)
	      	.attr("height", 60)*/
		}

		node.append("text")
			.attr("dx", -2)
			.attr("dy", ".35em")
			.attr("alignment-baseline", "center")
			.text(function(d) { return d.nid });

		var diagonal = d3.svg.diagonal()
 			.projection(function(d) { return [d.y, d.x]; });

		force.on("tick", function() {

			// Re-set x position for each node
			for (var i=0; i<nodes.length; i++) { 
				colPos = myInts[i+1];
				var nodesX = (chartWidth/2 - mapWidth/2) + ((colPos - 1) * gridSpacing);
				// round to nearest grid position
				nodes[i].x = nodesX;
				nodes[i].px = nodesX;
			}

			// draw curves
		    link.attr("d", function(d) {
				var startX = d.source.x;
				var startY = d.source.y;
				var endX = d.target.x;
				var endY = d.target.y;
				var startQX = startX+(.4*(endX-startX));
				var startQY = startY;
				var endQX = startX+((endX-startX)/2);
				var endQY = startY+((endY-startY)/2);
				return "M" + startX + "," + startY + " " + "Q" + startQX + "," + startQY + " " + endQX + "," + endQY + " " + "T" + endX + "," + endY;
			});

		    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
		});
		

		

	} // * END getData function *

	// target data, call the function
	var theData = "sampledata2.csv";
	d3.csv(theData, getData);


</script>

</body>
</html>
