<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Bloomcase Layout</title>
<link href="style.css" rel="stylesheet" type="text/css" />
<script src="d3.v3.min.js"></script>
<script src="bloomcase_layout.js"></script>
</head>

<body onload="drawBloomcase()">
<div id="modalOptions" style="position:fixed;left:100px;right:200px;background:red;height:100px;width:100px;display:none;">Options!</div>
<h1>Bloomcase Layout</h1>

<svg id="timeline">
</svg>
<div id="info">
</div>

<script>

    rowSize = 50;
    columnSize = 25;
    updatingNode = {};

function drawBloomcase() {
    
    newNodes = {};
    testLayout = new d3_layout_bloomcase();
    d3.json("new8.json", function(data) {
    newNodes = data;
    testLayout.nodes(newNodes.nodes);
    
    d3.select("svg").append("g").attr("id", "bloomG");    

    drawBC(testLayout.nodes(),testLayout.links());
    });
    
}

    var curvyLine = function(startPoint,endPoint) {

	var xStep = (endPoint[0] - startPoint[0]);
	var yStep = (endPoint[1] - startPoint[1]);
	var xyDiff = Math.abs(yStep) - rowSize;
	var firstDiff = xyDiff * .375;
	var secDiff = xyDiff * .17;
		
	if (startPoint[1] < endPoint[1]) {
	return "M" + startPoint[0] + "," + startPoint[1] + "c" + (xStep + firstDiff) + ",0 " + (-secDiff) + ","+ (yStep) + " " + xStep + "," + yStep;
	}
	else if (startPoint[1] > endPoint[1]) {
	return "M" + startPoint[0] + "," + startPoint[1] + "c" + (xStep + firstDiff) + ",0 " + (-secDiff) + ","+ (yStep) + " " + xStep + "," + yStep;
	    
	}
	else {
	return "M" + startPoint[0] + "," + startPoint[1] + "c0,0 "+xStep+"," + (yStep) + " " + xStep + "," + yStep;
	}
    }
    
function drawBC(nodeData,linkData) {
    d3.selectAll("path.connections").remove();
    d3.selectAll("g.sec").remove();
    
    d3.select("#bloomG").selectAll("path.connections").data(linkData).enter().append("path")
    .style("stroke", "black")
    .attr("class", "connections")
    .style("stroke-width", 2)
    .style("fill", "none")
    .attr("d", function(d) {return "M"+rowSize+"," + (200) + "c0,0 0,0 0,0"})
    
    var secG = d3.select("#bloomG").selectAll("g.sec").data(nodeData).enter().append("g")
    .style("display", function(d) {return d.isMeta ? "none" : "block"})
    .attr("class", "sec")
    .attr("transform", function(d,i) {return "translate(30,200)"})
    .on("mousedown", startMove)
    .on("mouseup", endMove)

    
    secG.append("path")
    .attr("class", function(d){ return d.kind; })
    .attr("d", function(d,i) {return shapeMeasures[d.kind]["pathd"]})
    .attr("transform", function(d) { 
	return "translate(" + (-1*(shapeMeasures[d.kind]["myWidth"]/2)) + "," + (-1*(shapeMeasures[d.kind]["myHeight"]/2)) + ")"; 
    });

    secG.append("text")
                .attr("dx", -1)
                .attr("dy", ".35em")
                .attr("alignment-baseline", "center")
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .text(function(d) { return d.nid });
		
    redrawBC();
}

function redrawBC() {
    d3.selectAll("g.sec").transition().duration(1000)
    .attr("transform", function(d,i) {return "translate("+ (d.column * columnSize) +","+ (200 + (d.row * rowSize)) +")"})
    
    d3.selectAll("path.connections").transition()
    .duration(1000)
    .attr("d", function(d) {return curvyLine([d.source.column * columnSize, (200 + d.source.row * rowSize)],[d.target.column * columnSize, (200 + d.target.row * rowSize)]) });

}

function startMove(d,i) {
    if (!d3.select("#genNode").empty()) {return;}
    updatingNode = d;
    var curMouse = d3.mouse(this.parentNode);
    d3.select("#bloomG").on("mousemove", moveGenNode)
    d3.select("#bloomG").on("mouseup", endMove)
    d3.select("#bloomG").append("line")
    .attr("id", "genLine")
    .attr("x1", d.column * columnSize)
    .attr("y1", (200 + d.row * rowSize))
    .attr("x2", curMouse[0])
    .attr("y2", curMouse[1])
    .style("stroke", "gray")
    .style("stroke-width", 3)
    d3.select("#bloomG").append("g")
    .attr("id","genNode")
    .on("click", function() {d3.select("#modalOptions").style("display","block");d3.select("#genNode").remove();d3.select("#genLine").remove()})
    .attr("transform","translate("+curMouse[0]+","+curMouse[1]+")").append("circle").attr("r","1").style("fill", "lightgray").style("opacity", 0).transition().duration(300).style("opacity",1).attr("r",20)

}

function endMove(d,i) {
    if (!d3.select(".options").empty()) {return;}

    var curMouse = d3.mouse(this);

    d3.select("#bloomG").on("mousemove", null)
    
    d3.select("#genNode")
    .append("circle")
    .style("fill", "none")
    .style("stroke", "brown")
    .style("stroke-width", 1)
    .attr("r", 0)
    .transition()
    .duration(500)
    .attr("r", 100)
    
    function pointsOnCircle(shapeType,inc) {
	var circx = 100 * Math.cos(15 * inc);
	var circy = 100 * Math.sin(15 * inc);
	return ((-1*(shapeMeasures[shapeType]["myWidth"]/2)) + circx)+","+(circy + (-1*(shapeMeasures[shapeType]["myHeight"]/2)));
    }
    
    var possibleShapes = ["Inspiration", "Final", "Draft", "Sketch", "Idea"]
    d3.select("#genNode").selectAll("path.options").data(possibleShapes)
    .enter()
    .append("path")
    .attr("class", function(p){ return "options " + p; })
    .attr("d", function(p) {
	return shapeMeasures[p]["pathd"]
    })
    .attr("transform", function(p) { 
	return "translate(" + (-1*(shapeMeasures[p]["myWidth"]/2)) + "," + (-1*(shapeMeasures[p]["myHeight"]/2)) + ")scale(.1)"; 
    })
    .on("click", function(p) {createNewNode(p,d)})
    .transition()
    .duration(500)
    .attr("scale",1)
    .attr("transform", function (p,q) {return "translate("+ pointsOnCircle(p,q) + ")scale(1)"})
}

function createNewNode(d,i) {
    console.log("create")
    var genLineX1 = parseInt(d3.select("#genLine").attr("x1"))
    var genLineX2 = parseInt(d3.select("#genLine").attr("x2"))
    var forBack = genLineX2 - genLineX1;
    var evolvedVal = "";
    var newNodeID = "100" + testLayout.nodes().length;
    if (forBack > 0) {
	evolvedVal = updatingNode.nid;
    }
    else {
	updatingNode.evolvedFrom.length == 0 ? updatingNode.evolvedFrom = newNodeID : updatingNode.evolvedFrom += ("," + newNodeID)
    }
    
    var newNode = {nid: newNodeID,
    kind: d, datetime: testLayout.nodes()[0].datetime,
    timestamp: testLayout.nodes()[0].timestamp,
    row: -1,
    column: -1,
    isMeta: false,
    evolvedFrom: evolvedVal}
    
    testLayout.nodes().push(newNode)
    newNodeArray = testLayout.nodes().filter(function(el) {return el.isMeta ? null : this});
    
    freshLayout = new d3_layout_bloomcase();
    freshLayout.nodes(newNodeArray);
    
    drawBC(freshLayout.nodes(),freshLayout.links())
//    testLayout.nodes(newNodeArray);
//    redrawBC();
}

function moveGenNode(d,i) {
    var curMouse = d3.mouse(this);
    d3.select("#genNode")
    .attr("transform","translate("+curMouse[0]+","+curMouse[1]+")")
    
    d3.select("#genLine")
    .attr("x2", curMouse[0])
    .attr("y2", curMouse[1])
    
}


    </script>
    
    
</body>
</html>
